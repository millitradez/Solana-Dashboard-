<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Solana Trading — Mainnet (manual approve)</title>
<style>
  body{font-family:Inter,Arial,sans-serif;background:#041826;color:#e8f7ff;margin:0;padding:18px}
  .wrap{max-width:980px;margin:0 auto}
  .panel{background:rgba(255,255,255,0.03);padding:14px;border-radius:10px;margin-bottom:12px}
  input,select,button{padding:8px;border-radius:8px;border:none;background:rgba(255,255,255,0.02);color:inherit}
  button{background:#00c853;color:#002;font-weight:700;cursor:pointer}
  button.ghost{background:transparent;border:1px solid rgba(255,255,255,0.06)}
  .muted{color:#9fc3e6;font-size:13px}
  .log{font-family:monospace;background:#001b33;padding:10px;border-radius:8px;color:#9ff3d0;max-height:220px;overflow:auto}
  .row{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
  footer{font-size:13px;color:#a9cfe7;margin-top:12px}
</style>
</head>
<body>
<div class="wrap">
  <h2>Solana Manual Trade (Mainnet)</h2>
  <div class="muted">Paste a token mint, get an on-chain Jupiter quote, then approve the swap in your wallet. <strong>YOU must confirm signing.</strong></div>

  <div class="panel">
    <div class="row">
      <button id="connectBtn">Connect Wallet</button>
      <div id="walletShort" class="muted">Not connected</div>
      <div style="margin-left:auto" class="muted">Network: <strong>mainnet-beta</strong></div>
    </div>
  </div>

  <div class="panel">
    <div><strong>Token / Inspect</strong></div>
    <div style="margin-top:8px" class="row">
      <input id="mintInput" placeholder="Paste token mint (SPL) e.g. EPjFW..." style="flex:1"/>
      <select id="quick">
        <option value="">Quick</option>
        <option value="So11111111111111111111111111111111111111112">wSOL (SOL)</option>
        <option value="EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v">USDC</option>
        <option value="DezXAZ8z7PnrnRJjz3wXBoRgixCa6xjr9mXAdrsXgPa">BONK</option>
      </select>
      <button id="inspectBtn" class="ghost">Submit</button>
    </div>
    <div id="inspectResult" class="muted" style="margin-top:10px">No token selected</div>
  </div>

  <div class="panel">
    <div><strong>Quote & Trade</strong></div>
    <div style="margin-top:8px" class="row">
      <input id="amountInput" placeholder="Amount (SOL or token, e.g. 0.1)" style="width:160px"/>
      <select id="side">
        <option value="sol-to-token">Buy (SOL → token)</option>
        <option value="token-to-sol">Sell (token → SOL)</option>
      </select>
      <input id="slippageInput" placeholder="Slippage %" style="width:100px" value="1"/>
      <button id="quoteBtn" class="ghost">Get Quote</button>
    </div>

    <div id="quoteBox" style="margin-top:10px" class="muted">
      Quote will appear here.
    </div>

    <div style="margin-top:10px" class="row">
      <button id="executeBtn">Execute (Open sign prompt)</button>
      <button id="openJupiterBtn" class="ghost">Open on Jupiter (preview)</button>
    </div>
  </div>

  <div class="panel">
    <div><strong>Logs</strong></div>
    <div id="log" class="log" style="margin-top:8px">Ready.</div>
  </div>

  <footer>
    <strong>WARNING:</strong> This page will create and broadcast MAINNET transactions once you approve the wallet signature. Double-check amounts, slippage, and mint addresses. Start very small. I am not responsible for losses.
  </footer>
</div>

<script type="module">
/* Mainnet-ready swap UI (manual approval).

  How it works:
  - detect Phantom / Coin98 wallet provider
  - inspect token mint via CoinGecko (if available)
  - request Jupiter quote for SOL↔token (mainnet quote API)
  - request Jupiter swap payload (POST swap endpoint) to receive base64 swapTransaction
  - decode into Transaction, ask wallet to sign (provider.signTransaction)
  - send to mainnet RPC via web3.js connection.sendRawTransaction
  - confirm and show txid

  IMPORTANT: You must review the wallet popup thoroughly and only approve if you accept the costs.
*/

import { Connection, Transaction, PublicKey } from "https://esm.sh/@solana/web3.js@1.95.1";

// Configuration (MAINNET)
const RPC = "https://api.mainnet-beta.solana.com";
const connection = new Connection(RPC, "confirmed");
const JUPITER_QUOTE = "https://quote-api.jup.ag/v4/quote";
const JUPITER_SWAP = "https://api.jup.ag/swap/v1/swap"; // public endpoint for swap payloads
const SOL_MINT = "So11111111111111111111111111111111111111112";

const connectBtn = document.getElementById("connectBtn");
const walletShort = document.getElementById("walletShort");
const mintInput = document.getElementById("mintInput");
const inspectBtn = document.getElementById("inspectBtn");
const quick = document.getElementById("quick");
const inspectResult = document.getElementById("inspectResult");
const amountInput = document.getElementById("amountInput");
const sideSelect = document.getElementById("side");
const slippageInput = document.getElementById("slippageInput");
const quoteBtn = document.getElementById("quoteBtn");
const quoteBox = document.getElementById("quoteBox");
const executeBtn = document.getElementById("executeBtn");
const openJupiterBtn = document.getElementById("openJupiterBtn");
const logEl = document.getElementById("log");

function log(msg){
  logEl.innerHTML = `[${new Date().toLocaleTimeString()}] ${msg}<br>` + logEl.innerHTML;
  console.debug(msg);
}

// Wallet provider vars
let provider = null;
let connectedPubkey = null;
let lastQuote = null; // store the selected route (best) for swap build

async function detectProvider(){
  if (window.coin98 && window.coin98.sol) { provider = window.coin98.sol; log("Detected Coin98 provider"); }
  else if (window.solana && window.solana.isPhantom) { provider = window.solana; log("Detected Phantom provider"); }
  else { provider = null; log("No wallet provider detected (open in Phantom/Coin98)"); }
  connectBtn.textContent = provider ? "Connect Wallet" : "Open in Phantom/Coin98";
}

// Connect wallet
async function connectWallet(){
  if (!provider) { alert("Open this page in Phantom or Coin98 with mainnet wallet"); return; }
  try {
    const res = provider.connect ? await provider.connect() : await provider.request({ method: "connect" });
    const pub = res?.publicKey?.toString?.() || (res?.toString?.()||res);
    connectedPubkey = pub;
    walletShort.textContent = `Connected: ${pub.slice(0,6)}...${pub.slice(-4)}`;
    log("Wallet connected: " + pub);
  } catch(e){
    log("Wallet connect failed: " + (e.message || e));
    walletShort.textContent = "Connection rejected";
  }
}

// Inspect token mint (CoinGecko lookup + set iframe preview)
inspectBtn.addEventListener("click", async ()=>{
  const mint = (mintInput.value || "").trim();
  if (!mint) { inspectResult.textContent = "Enter a token mint."; return; }
  try {
    // verify pubkey format
    new PublicKey(mint);
  } catch(e){
    inspectResult.textContent = "Invalid mint address.";
    return;
  }
  inspectResult.textContent = "Checking CoinGecko for price...";
  try {
    const cg = await fetch(`https://api.coingecko.com/api/v3/simple/token_price/solana?contract_addresses=${mint}&vs_currencies=usd`).then(r=>r.json());
    const price = cg[mint.toLowerCase()]?.usd ?? null;
    inspectResult.innerHTML = price ? `Price (CoinGecko): $${Number(price).toFixed(6)}` : "Price not found on CoinGecko";
    // set iframe to DexScreener search (optional)
    // document.getElementById('dexIframe')?.setAttribute('src', 'https://dexscreener.com/search?q=' + encodeURIComponent(mint));
  } catch(e){
    inspectResult.textContent = "Inspect failed: " + e.message;
  }
});

// Quick pick
quick.addEventListener("change", ()=>{ if (quick.value) mintInput.value = quick.value; });

// Get Jupiter quote (mainnet)
quoteBtn.addEventListener("click", async ()=>{
  const mint = (mintInput.value || "").trim();
  if (!mint) { quoteBox.textContent = "Enter a token mint."; return; }
  try { new PublicKey(mint); } catch(e){ quoteBox.textContent = "Invalid mint address."; return; }

  const side = sideSelect.value;
  const amountUi = parseFloat(amountInput.value);
  if (!amountUi || amountUi <= 0) { quoteBox.textContent = "Enter valid amount."; return; }

  // Prepare input/output mints and amount in smallest units
  let inputMint, outputMint, amountSmall;
  if (side === "sol-to-token"){ inputMint = SOL_MINT; outputMint = mint; amountSmall = Math.floor(amountUi * 1e9); }
  else { inputMint = mint; outputMint = SOL_MINT; // token->SOL; approximate decimals: many tokens have 6 decimals; this is a practical assumption but may be inaccurate — Jupiter expects exact smallest units
    amountSmall = Math.floor(amountUi * 1e6);
  }

  const slippage = parseFloat(slippageInput.value) || 1;

  const url = `${JUPITER_QUOTE}?inputMint=${inputMint}&outputMint=${outputMint}&amount=${amountSmall}&slippage=${slippage}`;
  quoteBox.textContent = "Requesting quote from Jupiter...";
  log("Requesting Jupiter quote...");

  try {
    const r = await fetch(url);
    if (!r.ok) throw new Error("Jupiter quote failed: " + r.status);
    const j = await r.json();
    if (!j.data || j.data.length === 0) { quoteBox.textContent = "No route found"; lastQuote = null; return; }
    // choose best (first) route from Jupiter
    const best = j.data[0];
    lastQuote = best;
    // compute approximate out in UI units using guess decimals (best effort)
    const outDecimals = 9; // default fallback; ideally read token registry for exact decimals
    const outUi = best.outAmount / Math.pow(10, outDecimals);
    quoteBox.innerHTML = `Estimated out: ${outUi.toFixed(6)}<br>Route: ${best.marketInfos?.map(m=>m.label).join(' → ')}<br><small>Check slippage & route carefully.</small>`;
    // set Jupiter preview link
    const jupUrl = `https://jup.ag/swap?inputMint=${inputMint}&outputMint=${outputMint}&amount=${amountSmall}&slippage=${slippage}`;
    openJupiterBtn.onclick = ()=> window.open(jupUrl, "_blank");
    openJupiterBtn.style.display = "inline-block";
    log("Quote received and stored locally. Ready to build swap.");
  } catch(e){
    quoteBox.textContent = "Quote error: " + e.message;
    log("Quote error: " + e.message);
    lastQuote = null;
  }
});

// Execute: build swap via Jupiter swap endpoint, sign in wallet, send to mainnet
executeBtn.addEventListener("click", async ()=>{
  if (!lastQuote) { alert("Get a quote first."); return; }
  if (!provider) { alert("Open this page in Phantom/Coin98 and connect wallet."); return; }
  if (!connectedPubkey){
    await connectWallet();
    if (!connectedPubkey) { alert("Connect wallet first."); return; }
  }

  // show confirmation dialog with key details
  const side = sideSelect.value;
  const amt = amountInput.value;
  if (!confirm(`You are about to ${side === "sol-to-token" ? "buy" : "sell"} ${amt} (input). This will construct a MAINNET transaction and ask your wallet to sign. Proceed?`)) return;

  try {
    log("Requesting Jupiter swap build (server-side swap builder)...");
    // Jupiter swap endpoint expects JSON { route, userPublicKey } OR other fields; we'll pass route object and userPublicKey
    const body = { route: lastQuote, userPublicKey: connectedPubkey };
    const res = await fetch(JUPITER_SWAP, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(body)
    });
    if (!res.ok){
      const text = await res.text();
      throw new Error("Jupiter swap build failed: " + res.status + " " + text);
    }
    const json = await res.json();
    if (!json || !json.swapTransaction) throw new Error("Jupiter did not return swapTransaction");
    const b64 = json.swapTransaction; // base64 string
    // decode to Transaction
    const raw = Uint8Array.from(atob(b64), c => c.charCodeAt(0));
    const tx = Transaction.from(raw);

    log("Requesting wallet to sign transaction (inspect details in wallet popup)...");
    // Some wallets expose different methods:
    let signedTx;
    if (provider.signTransaction) {
      signedTx = await provider.signTransaction(tx);
    } else if (provider.sign && provider.signTransaction) {
      signedTx = await provider.signTransaction(tx);
    } else {
      throw new Error("Wallet does not support signTransaction in this environment");
    }

    // send serialized signed tx
    const signedSerialized = signedTx.serialize();
    log("Sending signed transaction to mainnet...");
    const txid = await connection.sendRawTransaction(signedSerialized, { skipPreflight: false });
    log("Submitted txid: " + txid);
    quoteBox.innerHTML += `<div style="margin-top:8px">Submitted tx: <a href="https://explorer.solana.com/tx/${txid}?cluster=mainnet-beta" target="_blank">${txid}</a></div>`;
    // confirm
    await connection.confirmTransaction(txid, "confirmed");
    log("Transaction confirmed: " + txid);
    alert("Transaction confirmed: " + txid);
  } catch(e){
    log("Swap execution failed: " + (e.message || e));
    alert("Swap failed: " + (e.message || e));
  }
});

// Detect provider on load
window.addEventListener("load", async ()=>{
  await detectProvider();
  // if provider available and auto-connect desired, you could auto-connect here (not done by default)
  connectBtn.addEventListener("click", connectWallet);
  quick.addEventListener("change", ()=> { if (quick.value) mintInput.value = quick.value });
  // optionally auto-inspect default
  //mintInput.value = SOL_MINT; inspectBtn.click();
});

</script>
</body>
</html>
