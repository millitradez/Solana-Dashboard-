<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>Solana Dashboard ‚Äî Token Search, Watchlist & DEX Screener</title>
  <style>
    :root{--bg:#04192b;--card:rgba(255,255,255,0.04);--accent:#00c853;--muted:#9fc3e6}
    body{margin:0;font-family:Inter,system-ui,Arial,sans-serif;background:linear-gradient(180deg,#02243a,#00385a);color:#eaf6ff;min-height:100vh;display:flex;justify-content:center;padding:20px}
    .wrap{width:100%;max-width:1200px}
    .top{display:flex;gap:12px;align-items:center;flex-wrap:wrap;margin-bottom:12px}
    h1{margin:0;font-size:20px}
    .card{background:var(--card);border-radius:10px;padding:12px}
    button{background:var(--accent);border:none;color:#002;padding:10px 12px;border-radius:8px;cursor:pointer;font-weight:700}
    button.ghost{background:transparent;border:1px solid rgba(255,255,255,0.06);color:#cde6ff}
    input,select,textarea{padding:8px;border-radius:8px;border:none;background:rgba(255,255,255,0.03);color:inherit}
    .grid{display:grid;grid-template-columns:1fr 420px;gap:12px}
    .box{padding:12px;border-radius:8px;background:rgba(0,0,0,0.35)}
    .muted{color:var(--muted);font-size:13px}
    .tokenRow{display:flex;justify-content:space-between;align-items:center;padding:8px;border-radius:8px;margin-bottom:6px;background:rgba(255,255,255,0.02)}
    .tokenRow .left{display:flex;gap:10px;align-items:center}
    .tokenLogo{width:34px;height:34px;border-radius:6px;object-fit:cover;display:inline-block}
    .tokensList{max-height:420px;overflow:auto;padding-right:8px}
    .small{font-size:13px}
    .log{font-family:monospace;background:#001629;padding:10px;border-radius:6px;color:#9ff3d0;max-height:160px;overflow:auto}
    .watchlistItem{display:flex;gap:8px;align-items:center;padding:6px;border-radius:6px;background:rgba(255,255,255,0.02);margin-bottom:6px}
    .controls{display:flex;gap:8px;align-items:center}
    .pageControls{display:flex;gap:6px;align-items:center;margin-top:8px}
    a.linkBtn{background:#ffb300;padding:8px 12px;border-radius:8px;color:#001;text-decoration:none;font-weight:700}
    footer{margin-top:12px;color:var(--muted);font-size:13px;text-align:center}
    @media(max-width:960px){.grid{grid-template-columns:1fr}}
  </style>
</head>
<body>
  <div class="wrap">
    <div class="top">
      <div style="flex:1">
        <h1>üåê Solana Dashboard ‚Äî Search, Watchlist & DEX Screener</h1>
        <div class="muted">Connect wallet (Coin98 or Phantom) to show balances; search / watch thousands of tokens; request Jupiter quotes.</div>
      </div>
      <div class="controls">
        <button id="connectBtn">Connect Wallet</button>
        <div id="walletBrief" class="muted small" style="margin-left:8px">Not connected</div>
      </div>
    </div>

    <div class="grid">
      <!-- LEFT: Search / token list / results -->
      <div>
        <div class="card box">
          <div style="display:flex;gap:8px;align-items:center;flex-wrap:wrap">
            <input id="searchInput" placeholder="Search by name, symbol or mint (typeahead)..." style="flex:1"/>
            <select id="perPage"><option>25</option><option selected>50</option><option>100</option></select>
            <button id="reloadRegistry" class="ghost">Reload registry</button>
          </div>
          <div style="margin-top:10px;display:flex;gap:8px;align-items:center;flex-wrap:wrap">
            <button id="openWatchlistView" class="ghost">Watchlist</button>
            <button id="bulkImportBtn" class="ghost">Bulk Import</button>
            <div class="muted small" id="registryStatus">Loading token registry...</div>
          </div>
        </div>

        <div class="card box" style="margin-top:12px">
          <div style="display:flex;justify-content:space-between;align-items:center">
            <div><strong>Token results</strong> <span id="resultCount" class="muted small"></span></div>
            <div class="muted small">Cached pages & batched pricing</div>
          </div>

          <div id="tokensContainer" class="tokensList" style="margin-top:8px"></div>

          <div class="pageControls">
            <button id="prevPage" class="ghost">Prev</button>
            <div id="pageInfo" class="muted small">Page 1</div>
            <button id="nextPage" class="ghost">Next</button>
          </div>
        </div>

        <div class="card box" style="margin-top:12px">
          <div style="display:flex;justify-content:space-between;align-items:center">
            <div><strong>Selected / Inspector</strong></div>
            <div class="muted small">Detects wallet vs token</div>
          </div>
          <div style="margin-top:8px">
            <input id="inspectInput" placeholder="Paste token mint or wallet address and click Inspect" style="width:100%"/>
            <div style="display:flex;gap:8px;margin-top:8px">
              <button id="inspectBtn" class="ghost">Inspect</button>
              <select id="quickTokens">
                <option value="">Quick: pick a token</option>
                <option value="So11111111111111111111111111111111111111112">wSOL</option>
                <option value="EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v">USDC</option>
                <option value="DezXAZ8z7PnrnRJjz3wXBoRgixCa6xjr9mXAdrsXgPa">BONK</option>
              </select>
              <button id="quoteBtn" class="ghost">Get Quote (Jupiter)</button>
            </div>
            <div id="inspectResult" style="margin-top:8px"></div>
          </div>
        </div>
      </div>

      <!-- RIGHT: Wallet balances, watchlist, logs, quote -->
      <div>
        <div class="card box">
          <div style="display:flex;justify-content:space-between;align-items:center">
            <div><strong>Wallet Balances</strong></div>
            <div class="muted small">SOL & SPL</div>
          </div>
          <div id="balances" style="margin-top:8px" class="muted">Not connected</div>
          <div id="tokenBalances" style="margin-top:8px"></div>
        </div>

        <div class="card box" style="margin-top:12px">
          <div style="display:flex;justify-content:space-between;align-items:center">
            <div><strong>Watchlist</strong></div>
            <div class="muted small">localStorage</div>
          </div>
          <div id="watchlist" style="margin-top:8px"></div>
          <div style="margin-top:8px;display:flex;gap:8px">
            <button id="exportWatchlist" class="ghost">Export CSV</button>
            <button id="clearWatchlist" class="ghost">Clear</button>
          </div>
        </div>

        <div class="card box" style="margin-top:12px">
          <div style="display:flex;justify-content:space-between;align-items:center">
            <div><strong>Quote / Route</strong></div>
            <div class="muted small">Open on Jupiter for final swap</div>
          </div>
          <div style="margin-top:8px;display:flex;gap:8px;align-items:center">
            <input id="quoteAmount" placeholder="Amount (SOL or token)" style="min-width:160px"/>
            <select id="quoteDirection"><option value="sol-to-token">SOL ‚Üí Token</option><option value="token-to-sol">Token ‚Üí SOL</option></select>
            <button id="runQuote" class="ghost">Run</button>
          </div>
          <div id="quoteArea" style="margin-top:8px"></div>
        </div>

        <div class="card box" style="margin-top:12px">
          <div><strong>Logs</strong></div>
          <div id="log" class="log" style="margin-top:8px"></div>
        </div>
      </div>
    </div>

    <footer class="muted">Tip: Open this page inside Coin98 or Phantom browser to use wallet features. Quotes are read-only ‚Äî swaps open Jupiter where you'll sign.</footer>
  </div>

  <script type="module">
  /**********************************************************************
   * Full client-only implementation:
   * - loads Solana token-list (token registry)
   * - search + pagination
   * - watchlist (localStorage) + bulk import/export
   * - batched CoinGecko price requests (group size configurable)
   * - wallet connect (Coin98 or Phantom), fetch SOL + parsed token accounts
   * - Jupiter quote (public quote endpoint) and "Open on Jupiter" link
   *
   * Safety: read-only. No signing or sending of txns here.
   **********************************************************************/

  import { Connection, PublicKey, clusterApiUrl } from "https://esm.sh/@solana/web3.js@1.95.1";

  /* ---------------- Config ---------------- */
  const SOL_MINT = 'So11111111111111111111111111111111111111112';
  const COINGECKO_BATCH = 50;              // how many mints per CoinGecko batch request
  const PRICE_CACHE_TTL = 45 * 1000;       // 45 seconds
  const REGISTRY_TTL = 24 * 60 * 60 * 1000; // 24 hours
  const JUPITER_QUOTE_API = 'https://quote-api.jup.ag/v4/quote';
  const TOKEN_LIST_URL = 'https://raw.githubusercontent.com/solana-labs/token-list/main/src/tokens/solana.tokenlist.json';

  /* ---------------- State ---------------- */
  const connection = new Connection(clusterApiUrl('mainnet-beta'));
  let tokenRegistry = {};   // lower(mint) -> metadata
  let tokenIndex = [];      // array of tokens for search
  let priceCache = {};      // mint -> {price, ts}
  let currentPage = 1;
  let perPage = parseInt(document.getElementById('perPage').value || '50', 10);
  let provider = null;
  let connectedPubkey = null;

  /* ---------------- DOM ---------------- */
  const logEl = document.getElementById('log');
  const registryStatus = document.getElementById('registryStatus');
  const tokensContainer = document.getElementById('tokensContainer');
  const resultCount = document.getElementById('resultCount');
  const pageInfo = document.getElementById('pageInfo');
  const prevPage = document.getElementById('prevPage');
  const nextPage = document.getElementById('nextPage');
  const searchInput = document.getElementById('searchInput');
  const perPageSelect = document.getElementById('perPage');
  const connectBtn = document.getElementById('connectBtn');
  const walletBrief = document.getElementById('walletBrief');
  const balancesEl = document.getElementById('balances');
  const tokenBalancesEl = document.getElementById('tokenBalances');
  const watchlistEl = document.getElementById('watchlist');
  const reloadRegistry = document.getElementById('reloadRegistry');
  const openWatchlistView = document.getElementById('openWatchlistView');
  const bulkImportBtn = document.getElementById('bulkImportBtn');
  const inspectInput = document.getElementById('inspectInput');
  const inspectBtn = document.getElementById('inspectBtn');
  const inspectResult = document.getElementById('inspectResult');
  const quickTokens = document.getElementById('quickTokens');
  const quoteBtn = document.getElementById('quoteBtn');
  const runQuote = document.getElementById('runQuote');
  const quoteArea = document.getElementById('quoteArea');
  const quoteAmount = document.getElementById('quoteAmount');
  const quoteDirection = document.getElementById('quoteDirection');
  const quoteRunBtn = document.getElementById('runQuote');
  const quoteInputBtn = document.getElementById('quoteBtn');

  /* ---------------- Helpers ---------------- */
  function formatMint(m) { return (m||'').slice(0,6)+'...'+(m||'').slice(-4) }
  function time() { return new Date().toLocaleTimeString() }
  function log(s){ logEl.innerHTML += `[${time()}] ${s}<br>`; logEl.scrollTop = logEl.scrollHeight }
  function saveWatchlist(wl){ localStorage.setItem('watchlist_v1', JSON.stringify(wl||[])) }
  function loadWatchlist(){ try { return JSON.parse(localStorage.getItem('watchlist_v1')||'[]') } catch(e){return []} }

  /* ---------------- Token Registry ---------------- */
  async function loadTokenRegistry(force=false){
    try {
      registryStatus.textContent = 'Loading token registry...';
      const cached = JSON.parse(localStorage.getItem('token_registry_cache')||'null');
      if (!force && cached && Date.now() - cached.ts < REGISTRY_TTL) {
        tokenRegistry = cached.data;
        tokenIndex = Object.values(tokenRegistry);
        registryStatus.textContent = `Registry loaded (cached) ‚Äî ${tokenIndex.length} tokens`;
        log('Token registry loaded from cache');
        return;
      }
      const r = await fetch(TOKEN_LIST_URL);
      if (!r.ok) throw new Error('Failed to fetch token list: '+r.status);
      const j = await r.json();
      tokenRegistry = {};
      (j.tokens||[]).forEach(t => tokenRegistry[t.address.toLowerCase()] = t);
      tokenIndex = Object.values(tokenRegistry);
      localStorage.setItem('token_registry_cache', JSON.stringify({ts:Date.now(), data:tokenRegistry}));
      registryStatus.textContent = `Registry loaded ‚Äî ${tokenIndex.length} tokens`;
      log('Token registry fetched and cached: ' + tokenIndex.length);
    } catch(e){
      registryStatus.textContent = 'Registry error';
      log('Token registry load failed: '+e.message);
      tokenRegistry = {}; tokenIndex = [];
    }
  }

  /* ---------------- Search & Pagination ---------------- */
  function filterTokens(q){
    q = (q||'').trim().toLowerCase();
    if (!q) return tokenIndex.slice();
    const results = tokenIndex.filter(t=>{
      return (t.symbol||'').toLowerCase().includes(q) ||
             (t.name||'').toLowerCase().includes(q) ||
             (t.address||'').toLowerCase().includes(q);
    });
    return results;
  }

  function renderPage(page=1){
    perPage = parseInt(perPageSelect.value||'50',10);
    currentPage = page;
    const all = filterTokens(searchInput.value);
    const total = all.length;
    const pages = Math.max(1, Math.ceil(total / perPage));
    if (currentPage > pages) currentPage = pages;
    const start = (currentPage-1)*perPage;
    const slice = all.slice(start, start+perPage);
    tokensContainer.innerHTML = '';
    resultCount.textContent = `${total} tokens`;
    pageInfo.textContent = `Page ${currentPage}/${pages}`;
    slice.forEach(t => {
      const mint = t.address;
      const el = document.createElement('div'); el.className = 'tokenRow';
      const left = document.createElement('div'); left.className='left';
      const img = document.createElement('img'); img.className='tokenLogo'; img.src = t.logoURI || '';
      const lbl = document.createElement('div');
      lbl.innerHTML = `<div style="font-weight:700">${t.symbol || mint.slice(0,6)}</div><div class="muted small">${t.name||''}</div>`;
      left.appendChild(img); left.appendChild(lbl);
      const right = document.createElement('div');
      // price placeholder
      const priceSpan = document.createElement('div'); priceSpan.className='small muted'; priceSpan.textContent='‚Äî';
      // actions
      const addBtn = document.createElement('button'); addBtn.textContent='Watch'; addBtn.onclick = ()=>{ addToWatchlist(mint); };
      const inspectBtn = document.createElement('button'); inspectBtn.textContent='Inspect'; inspectBtn.style.marginLeft='6px'; inspectBtn.onclick=()=>inspect(mint);
      right.appendChild(priceSpan); right.appendChild(addBtn); right.appendChild(inspectBtn);
      el.appendChild(left); el.appendChild(right);
      tokensContainer.appendChild(el);

      // attach price fetch (deferred/batched)
      fetchPriceBatched(mint, priceSpan);
    });
  }

  /* ---------------- Price batching ---------------- */
  let pendingPriceRequests = new Set();
  let priceTimer = null;

  function queuePriceFetch(mint){
    pendingPriceRequests.add(mint.toLowerCase());
    if (priceTimer) return;
    priceTimer = setTimeout(flushPriceRequests, 300); // debounce short
  }

  async function flushPriceRequests(){
    priceTimer = null;
    const toFetch = Array.from(pendingPriceRequests);
    pendingPriceRequests.clear();
    // batch into groups of COINGECKO_BATCH
    for (let i=0;i<toFetch.length;i+=COINGECKO_BATCH){
      const group = toFetch.slice(i,i+COINGECKO_BATCH);
      await fetchPriceBatch(group);
    }
  }

  async function fetchPriceBatch(mints){
    // filter out cached and recent
    const now = Date.now();
    const need = mints.filter(m => !priceCache[m] || (now - priceCache[m].ts) > PRICE_CACHE_TTL);
    if (need.length === 0) return;
    try {
      log(`Fetching prices for ${need.length} tokens (batch)`);
      const url = `https://api.coingecko.com/api/v3/simple/token_price/solana?contract_addresses=${need.join(',')}&vs_currencies=usd&include_24hr_change=true`;
      const r = await fetch(url);
      if (!r.ok) throw new Error('CG error '+r.status);
      const j = await r.json();
      const ts = Date.now();
      need.forEach(m => {
        const entry = j[m] || null;
        priceCache[m] = { price: entry ? entry.usd : null, change: entry ? entry.usd_24h_change : null, ts };
      });
      // now update any visible price spans
      updateVisiblePrices();
    } catch(e){
      log('Price batch error: '+e.message);
    }
  }

  function updateVisiblePrices(){
    // scan DOM token rows and update price where possible
    document.querySelectorAll('.tokenRow').forEach(row=>{
      const left = row.querySelector('.left div.muted, .left div');
      const symbol = row.querySelector('.left div').innerText || '';
      // find mint from inspect button onclick? fallback: parse by span text - complicated, so better to set data-mint on row
    });
    // simpler: we've stored priceSpan earlier by closure; but that is per render
    // For simplicity, rerender current page to attach fresh prices into spans
    renderPage(currentPage);
  }

  // helper used while rendering to schedule price updates and set span text
  function fetchPriceBatched(mint, priceSpan){
    const key = mint.toLowerCase();
    // if cached and fresh
    const cached = priceCache[key];
    if (cached && (Date.now() - cached.ts) < PRICE_CACHE_TTL) {
      priceSpan.textContent = cached.price ? `$${Number(cached.price).toFixed(4)}` : '‚Äî';
      return;
    }
    // mark pending and set spinner
    priceSpan.textContent = '...';
    pendingPriceRequests.add(key);
    if (priceTimer) return;
    priceTimer = setTimeout(flushPriceRequests, 300);
  }

  /* ---------------- Watchlist ---------------- */
  function renderWatchlist(){
    const wl = loadWatchlist();
    watchlistEl.innerHTML = '';
    if (!wl.length) { watchlistEl.innerHTML = '<div class="muted small">Watchlist empty</div>'; return; }
    wl.forEach(mint=>{
      const div = document.createElement('div'); div.className='watchlistItem';
      const meta = tokenRegistry[mint.toLowerCase()];
      div.innerHTML = `<div style="flex:1"><strong>${meta ? meta.symbol : formatMint(mint)}</strong><div class="muted small">${meta ? meta.name : ''}</div></div>`;
      const viewBtn = document.createElement('button'); viewBtn.textContent='Inspect'; viewBtn.onclick=()=>inspect(mint);
      const removeBtn = document.createElement('button'); removeBtn.textContent='Remove'; removeBtn.onclick=()=>{ removeFromWatchlist(mint) };
      div.appendChild(viewBtn); div.appendChild(removeBtn);
      watchlistEl.appendChild(div);
    })
  }
  function addToWatchlist(mint){
    const wl = loadWatchlist();
    if (!wl.includes(mint)) { wl.push(mint); saveWatchlist(wl); renderWatchlist(); log('Added to watchlist: '+mint) }
  }
  function removeFromWatchlist(mint){
    let wl = loadWatchlist();
    wl = wl.filter(x=>x!==mint); saveWatchlist(wl); renderWatchlist(); log('Removed from watchlist: '+mint)
  }

  /* ---------------- Bulk import / export ---------------- */
  bulkImportBtn.onclick = async ()=>{
    const txt = prompt('Paste a comma/newline separated list of mint addresses:');
    if (!txt) return;
    const arr = txt.split(/[\s,]+/).map(x=>x.trim()).filter(Boolean);
    const valid = arr.filter(a=>{ try{ new PublicKey(a); return true } catch(e){return false} });
    const wl = loadWatchlist();
    const merged = Array.from(new Set([...wl, ...valid]));
    saveWatchlist(merged); renderWatchlist();
    log(`Imported ${valid.length} addresses into watchlist`);
  }
  document.getElementById('exportWatchlist').onclick = ()=>{
    const wl = loadWatchlist();
    const blob = new Blob([wl.join('\n')], {type:'text/plain'});
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a'); a.href = url; a.download = 'watchlist.txt'; a.click(); URL.revokeObjectURL(url);
  }
  document.getElementById('clearWatchlist').onclick = ()=>{
    if (!confirm('Clear watchlist?')) return;
    saveWatchlist([]); renderWatchlist(); log('Watchlist cleared');
  }

  /* ---------------- Wallet: detect & connect & balances ---------------- */
  async function detectProvider(){
    if (window.coin98 && window.coin98.sol) { provider = window.coin98.sol; log('Coin98 provider detected') }
    else if (window.solana && window.solana.isPhantom) { provider = window.solana; log('Phantom provider detected') }
    else { provider = null; log('No injected wallet provider detected') }
    connectBtn.textContent = provider ? 'Connect Wallet' : 'Open in Coin98/Phantom';
  }

  connectBtn.onclick = async ()=>{
    if (!provider) { alert('Open this page in Coin98 or Phantom browser to use wallet features'); return; }
    try {
      // some providers have connect(), some request()
      const resp = provider.connect ? await provider.connect() : await provider.request({method:'connect'});
      const pub = resp?.publicKey?.toString ? resp.publicKey.toString() : (resp?.toString?.()||resp);
      connectedPubkey = pub;
      walletBrief.textContent = `Connected: ${formatMint(pub)}`;
      log('Wallet connected: '+pub);
      await refreshBalances(pub);
    } catch (e) {
      log('Wallet connect rejected or failed: '+(e.message||e));
      walletBrief.textContent = 'Connection rejected';
    }
  }

  async function refreshBalances(pubkey){
    try {
      balancesEl.textContent = 'Fetching SOL balance...';
      const pk = new PublicKey(pubkey);
      const lam = await connection.getBalance(pk);
      const sol = lam/1e9;
      balancesEl.innerHTML = `<strong>${sol.toFixed(6)} SOL</strong>`;
      // token accounts
      tokenBalancesEl.innerHTML = '';
      const res = await connection.getParsedTokenAccountsByOwner(pk, { programId: new PublicKey("TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA") });
      const tokens = res.value.filter(a=>a.account.data.parsed.info.tokenAmount.uiAmount>0);
      if (!tokens.length) { tokenBalancesEl.innerHTML = '<div class="muted small">No SPL tokens</div>'; return; }
      for (const t of tokens){
        const info = t.account.data.parsed.info;
        const mint = info.mint;
        const amt = info.tokenAmount.uiAmount;
        const meta = tokenRegistry[mint.toLowerCase()];
        const div = document.createElement('div'); div.className='tokenItem';
        div.innerHTML = `<div style="display:flex;gap:8px;align-items:center"><img src="${meta?.logoURI||''}" class="tokenLogo"><div><strong>${meta?.symbol||formatMint(mint)}</strong><div class="muted small">${meta?.name||''}</div></div></div><div>${amt}</div>`;
        tokenBalancesEl.appendChild(div);
      }
    } catch(e){
      log('Error refreshing balances: '+e.message);
    }
  }

  /* ---------------- Inspect address (wallet vs token mint) ---------------- */
  function looksLikeKey(v){ try { new PublicKey(v); return true } catch(e){ return false } }

  async function inspect(addr){
    inspectResult.innerHTML = '';
    if (!addr) { inspectResult.innerHTML = '<div class="muted">Enter an address</div>'; return; }
    if (!looksLikeKey(addr)) { inspectResult.innerHTML = '<div class="danger">Invalid address</div>'; return; }
    const pk = new PublicKey(addr);
    // check if owner of token accounts (treat as wallet)
    try {
      const owned = await connection.getParsedTokenAccountsByOwner(pk, { programId: new PublicKey("TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA") });
      if (owned.value && owned.value.length>0){
        inspectResult.innerHTML = `<div><strong>Wallet:</strong> ${formatMint(addr)}</div><div class="muted small">Loading balances...</div>`;
        log('Inspect: address looks like a wallet; listing balances');
        const lam = await connection.getBalance(pk); const sol = lam/1e9;
        let html = `<div style="margin-top:8px"><strong>SOL:</strong> ${sol.toFixed(6)}</div>`;
        const tokens = owned.value.filter(a=>a.account.data.parsed.info.tokenAmount.uiAmount>0);
        if (tokens.length){
          html += '<div style="margin-top:8px"><strong>Tokens:</strong></div>';
          for (const t of tokens){
            const m = t.account.data.parsed.info.mint; const amt = t.account.data.parsed.info.tokenAmount.uiAmount;
            const meta = tokenRegistry[m.toLowerCase()];
            html += `<div style="margin-top:4px">${meta?.symbol||formatMint(m)} ‚Äî ${amt}</div>`;
          }
        } else html += '<div class="muted small">No SPL tokens with balance</div>';
        inspectResult.innerHTML = html;
        return;
      } else {
        // treat as token mint (try registry then coingecko)
        log('Inspect: no token accounts as owner ‚Äî treating as token mint');
        const meta = tokenRegistry[addr.toLowerCase()];
        if (meta){
          inspectResult.innerHTML = `<div><strong>Token:</strong> ${meta.name} (${meta.symbol})</div><div class="muted small">Checking price...</div>`;
          const price = await priceFromCoinGecko(addr);
          inspectResult.innerHTML += `<div style="margin-top:8px">${price ? `Price: $${price}` : 'Price not on CoinGecko'}</div>`;
          return;
        } else {
          inspectResult.innerHTML = `<div class="muted">Token mint not in registry. Try known mints or add to watchlist for on-demand quote.</div>`;
          return;
        }
      }
    } catch(e){ log('Inspect error: '+e.message); inspectResult.innerHTML = `<div class="danger">Error: ${e.message}</div>`; }
  }

  async function priceFromCoinGecko(mint){
    try {
      const url = `https://api.coingecko.com/api/v3/simple/token_price/solana?contract_addresses=${mint}&vs_currencies=usd`;
      const r = await fetch(url);
      const j = await r.json();
      return j[mint.toLowerCase()]?.usd ?? null;
    } catch(e){ log('CoinGecko price error: '+e.message); return null }
  }

  /* ---------------- Jupiter quote (simple) ---------------- */
  async function getJupiterQuote({inputMint, outputMint, amountLamports, slippageBps=100}){
    try {
      // public quote endpoint: amount is smallest units of inputMint
      const url = `${JUPITER_QUOTE_API}?inputMint=${inputMint}&outputMint=${outputMint}&amount=${amountLamports}&slippage=${Math.floor(slippageBps/100)}`;
      const r = await fetch(url);
      if (!r.ok) throw new Error('Quote API fail '+r.status);
      const j = await r.json(); return j;
    } catch(e){ throw e }
  }

  /* ---------------- UI actions ---------------- */
  prevPage.onclick = ()=>{ if (currentPage>1) renderPage(currentPage-1) }
  nextPage.onclick = ()=>{ currentPage++; renderPage(currentPage) }
  perPageSelect.onchange = ()=>{ currentPage=1; renderPage(1) }
  searchInput.oninput = debounce(()=>{ currentPage=1; renderPage(1) }, 250)
  reloadRegistry.onclick = ()=>loadTokenRegistry(true).then(()=>renderPage(1))
  openWatchlistView.onclick = ()=>{ // show watchlist in left panel by swapping tokens view to watchlist
    const wl = loadWatchlist();
    if (!wl.length) { alert('Watchlist empty'); return; }
    tokensContainer.innerHTML = '';
    resultCount.textContent = `${wl.length} watchlist tokens`;
    wl.forEach(mint=>{
      const meta = tokenRegistry[mint.toLowerCase()];
      const el = document.createElement('div'); el.className='tokenRow';
      el.innerHTML = `<div class="left"><img class="tokenLogo" src="${meta?.logoURI||''}"><div><strong>${meta?.symbol||formatMint(mint)}</strong><div class="muted small">${meta?.name||''}</div></div></div>`;
      const right = document.createElement('div');
      const inspectBtn = document.createElement('button'); inspectBtn.textContent='Inspect'; inspectBtn.onclick=()=>inspect(mint);
      const removeBtn = document.createElement('button'); removeBtn.textContent='Remove'; removeBtn.style.marginLeft='6px'; removeBtn.onclick=()=>{ removeFromWatchlist(mint) };
      right.appendChild(inspectBtn); right.appendChild(removeBtn);
      el.appendChild(right);
      tokensContainer.appendChild(el);
      // price
      const priceSpan = document.createElement('div');
      right.insertBefore(priceSpan, right.firstChild);
      fetchPriceBatched(mint, priceSpan);
    });
  }

  inspectBtn.onclick = ()=> inspect(inspectInput.value.trim())
  quickTokens.onchange = (e)=>{ if (e.target.value) inspectInput.value = e.target.value }
  quoteBtn.onclick = ()=>{ inspectInput.value = document.getElementById('inspectInput').value; getQuoteForInspect(); }
  runQuote.onclick = ()=>getQuoteForInspect();

  async function getQuoteForInspect(){
    const addr = inspectInput.value.trim();
    if (!addr || !looksLikeKey(addr)) { alert('Enter a valid mint address in Inspect'); return; }
    // get direction + amount
    const direction = quoteDirection.value;
    const amtStr = quoteAmount.value || '0.1';
    const amt = parseFloat(amtStr);
    if (!amt || amt <= 0) { alert('Enter a valid amount'); return; }
    let inputMint, outputMint, amountSmall;
    if (direction === 'sol-to-token'){ inputMint = SOL_MINT; outputMint = addr; amountSmall = Math.floor(amt * 1e9); }
    else { inputMint = addr; outputMint = SOL_MINT; // approximate decimals 6 for many tokens; this is best-effort
      amountSmall = Math.floor(amt * 1e6);
    }
    quoteArea.innerHTML = 'Requesting quote...';
    try {
      const q = await getJupiterQuote({inputMint, outputMint, amountLamports:amountSmall, slippageBps:100});
      if (!q.data || q.data.length===0) { quoteArea.innerHTML = '<div class="muted">No route found</div>'; log('Jupiter: no route'); return; }
      const best = q.data[0];
      // attempt to compute output units using registry decimals if present
      const outMeta = tokenRegistry[outputMint.toLowerCase()];
      const outDecimals = outMeta ? outMeta.decimals : 9;
      const outUi = best.outAmount / Math.pow(10, outDecimals);
      quoteArea.innerHTML = `<div><strong>Best output</strong>: ${outUi.toFixed(6)}</div><div class="muted small">${best.marketInfos?.map(m=>m.label).slice(0,3).join(' ‚Üí ')}</div><div style="margin-top:8px"><a class="linkBtn" href="https://jup.ag/swap?inputMint=${inputMint}&outputMint=${outputMint}&amount=${amountSmall}&slippage=1" target="_blank">Open Swap on Jupiter</a></div><pre class="muted small" style="margin-top:8px;color:#cfe">${JSON.stringify(best, null, 2)}</pre>`;
      log('Jupiter quote shown for '+inputMint+'->'+outputMint);
    } catch(e){
      quoteArea.innerHTML = `<div class="muted">Quote error: ${e.message}</div>`;
      log('Jupiter quote error: '+e.message);
    }
  }

  /* ---------------- Utilities ---------------- */
  function debounce(fn, t=200){ let timer; return (...a)=>{ clearTimeout(timer); timer=setTimeout(()=>fn(...a), t) } }

  /* ---------------- Init ---------------- */
  (async function init(){
    await loadTokenRegistry();
    renderPage(1);
    renderWatchlist();
    await detectProvider();
    // if provider present, show prompt to connect
    if (!provider) walletBrief.textContent = 'Open in Coin98 or Phantom browser to connect wallet';
    else walletBrief.textContent = 'Wallet available ‚Äî click Connect';
    log('UI ready');
  })();

  /* --------------- End of module --------------- */
  </script>
</body>
</html>
